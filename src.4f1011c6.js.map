{"version":3,"sources":["src/shader.js","src/index.js"],"names":["vertexShaderSource","fragmentShaderSource","gl","getContext","document","getElementById","viewport","drawingBufferWidth","drawingBufferHeight","clearColor","clear","COLOR_BUFFER_BIT","vertexShader","compileShader","VERTEX_SHADER","fragmentShader","FRAGMENT_SHADER","program","buildProgram","resolutionLocation","getUniformLocation","uniform2f","console","log","scaleX","uniform1f","gLEFT","scaleY","gTOP","enableVertexAttribArray","buffer","createBuffer","cleanup","useProgram","deleteBuffer","deleteProgram","canvas","width","clientWidth","height","clientHeight","source","type","shader","createShader","shaderSource","createProgram","attachShader","linkProgram","detachShader","deleteShader","getProgramParameter","LINK_STATUS","linkErrLog","getProgramInfoLog","Error","drawGL","canvasWidth","canvasHeight","lowerBoundr","lowerBoundi","upperBoundr","upperBoundi","gWIDTH","a_scaleX","a_gLEFT","a_scaleY","a_gTOP","bindBuffer","ARRAY_BUFFER","vertexAttribPointer","FLOAT","drawArrays","POINTS","hasExperimentalIsInputPending","navigator","scheduling","isInputPending","canvas2","ctx","imageData","getImageData","WIDTH","HEIGHT","bounds","makeXY","r","gHEIGHT","i","c","add","c1","c2","mult","scaler","iter","pzr","pzrs","pzis","zi","n","Math","log2","HSVtoRGB","h","s","v","g","b","f","p","q","t","arguments","length","floor","round","drawCanvas","data","color","value","toExponential","y","x","count","max","isMouseDown","draw","start","performance","now","putImageData","finish","JSON","stringify","draw2","addEventListener","event","xy","offsetY","offsetX","negc","preventDefault","scale","deltaY","prevMouseXY","canvasOnMouseMove","toFixed","prevC","diff","debounce","fn","delay","at_start","guarantee","timeout","args","self","Array","prototype","slice","call","setTimeout","run","apply","clearTimeout"],"mappings":"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","file":"src.4f1011c6.js","sourceRoot":"..","sourcesContent":["// TODO: Learn how I can make the shader interactive.\n\nconst vertexShaderSource = `\n#version 100\nvoid main() {\ngl_Position = vec4(0.0, 0.0, 0.0, 1.0);\ngl_PointSize = 600.0;\n}`\n\nconst fragmentShaderSource = `\n#ifdef GL_ES\nprecision highp float;\n#endif\n\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\nuniform float scaleX;\nuniform float scaleY;\nuniform float gLEFT;\nuniform float gTOP;\n\n// hsv2rgb source: https://stackoverflow.com/a/17897228\n// All components are in the range [0…1], including hue.\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 mandelbrot(vec2 pos){\n  float zx = pos.x * scaleX + gLEFT;\n  float zy = pos.y * scaleY + gTOP;\n  \n  const int maxIter = 1024;\n  \n  float cx = zx * 1.0;\n  float cy = zy * 1.0;\n  \n  float count = 0.0;\n  \n  for(int i = 0; i < maxIter; ++i){\n    if (zx * zx + zy * zy > 4.0) break;\n    \n    float temp = zx * zx - zy * zy;\n    \n    zy = 2.0 * zx * zy + cy;\n    zx = temp + cx;\n    \n    count += 1.0;\n  }\n  if (count == float(maxIter)) return vec3(0.0, 0.0, 0.0);\n  float smoothingMagic = 1.0 - log( (log2(zy * zy + zx * zx) / 2.0) / log(2.0) ) / log(2.0);\n  return hsv2rgb(vec3((count + smoothingMagic) / 100.0, 0.9, 1.0));\n}\n\nvoid main( void ) {\n  vec2 position = gl_FragCoord.xy / resolution;\n  vec3 color = mandelbrot(position);\n  gl_FragColor = vec4(color, 1.0 );\n}`\n\nlet gl = getContext(document.getElementById(\"canvas2\"));\n\ngl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);\ngl.clearColor(0.0, 0.0, 0.0, 1.0);\ngl.clear(gl.COLOR_BUFFER_BIT);\n\nlet vertexShader = compileShader(gl, vertexShaderSource, gl.VERTEX_SHADER);\nlet fragmentShader = compileShader(gl, fragmentShaderSource, gl.FRAGMENT_SHADER);\nlet program = buildProgram(gl, vertexShader, fragmentShader);\n\nvar resolutionLocation = gl.getUniformLocation(program, \"resolution\");\ngl.uniform2f(resolutionLocation, 600.0, 400.0);\nconsole.log(resolutionLocation);\n\nvar scaleX = gl.getUniformLocation(program, \"scaleX\");\ngl.uniform1f(scaleX, 3);\nvar gLEFT = gl.getUniformLocation(program, \"gLEFT\");\ngl.uniform1f(gLEFT, -2);\n\nvar scaleY = gl.getUniformLocation(program, \"scaleY\");\ngl.uniform1f(scaleY, 2.0);\nvar gTOP = gl.getUniformLocation(program, \"gTOP\");\ngl.uniform1f(gTOP, -1);\n\ngl.enableVertexAttribArray(0);\nconst buffer = gl.createBuffer();\ngl.bindBuffer(gl.ARRAY_BUFFER, buffer);\ngl.vertexAttribPointer(0, 1, gl.FLOAT, false, 0, 0);\n\ngl.drawArrays(gl.POINTS, 0, 1);\n\nfunction cleanup(gl, buffer, program) {\n  gl.useProgram(null);\n  if (buffer) gl.deleteBuffer(buffer);\n  if (program) gl.deleteProgram(program);\n}\n\nfunction getContext (canvas) {\n  canvas.width = canvas.clientWidth;\n  canvas.height = canvas.clientHeight;\n  return canvas.getContext(\"webgl\");\n}\n\nfunction compileShader (gl, source, type) {\n  const shader = gl.createShader(type);\n  gl.shaderSource(shader, source);\n  gl.compileShader(shader);\n  return shader;\n}\n\nfunction buildProgram (gl, vertexShader, fragmentShader) {\n  const program = gl.createProgram();\n  gl.attachShader(program, vertexShader);\n  gl.attachShader(program, fragmentShader);\n  gl.linkProgram(program);\n  gl.detachShader(program, vertexShader);\n  gl.detachShader(program, fragmentShader);\n  gl.deleteShader(vertexShader);\n  gl.deleteShader(fragmentShader);\n\n  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n    const linkErrLog = gl.getProgramInfoLog(program);\n    gl.useProgram(null);\n    gl.deleteProgram(program);\n    throw new Error(\"Shader program did not link successfully. \" + \"Error log: \" + linkErrLog);\n  }\n  gl.useProgram(program);\n  return program;\n}\n\nexport function drawGL(\n  canvasWidth,\n  canvasHeight,\n  lowerBoundr,\n  lowerBoundi,\n  upperBoundr,\n  upperBoundi\n) {\n  const gWIDTH = upperBoundr - lowerBoundr;\n  const gLEFT = lowerBoundr;\n  const scaleX = gWIDTH;\n\n  const gHEIGHT = upperBoundi - lowerBoundi;\n  const gTOP = lowerBoundi;\n  const scaleY = gHEIGHT;\n\n  var resolutionLocation = gl.getUniformLocation(program, \"resolution\");\n  gl.uniform2f(resolutionLocation, canvasWidth, canvasHeight);\n\n  var a_scaleX = gl.getUniformLocation(program, \"scaleX\");\n  gl.uniform1f(a_scaleX, scaleX);\n  var a_gLEFT = gl.getUniformLocation(program, \"gLEFT\");\n  gl.uniform1f(a_gLEFT, gLEFT);\n\n  var a_scaleY = gl.getUniformLocation(program, \"scaleY\");\n  gl.uniform1f(a_scaleY, scaleY);\n  var a_gTOP = gl.getUniformLocation(program, \"gTOP\");\n  gl.uniform1f(a_gTOP, gTOP);\n\n  gl.enableVertexAttribArray(0);\n  const buffer = gl.createBuffer();\n  gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n  gl.vertexAttribPointer(0, 1, gl.FLOAT, false, 0, 0);\n\n  gl.drawArrays(gl.POINTS, 0, 1);\n}\n","\"use strict\";\nimport { drawGL } from \"./shader.js\"\n// import { add as addRust, iter as iterRust } from \"./draw.rs\";\n\nconst hasExperimentalIsInputPending = navigator.scheduling && navigator.scheduling.isInputPending;\n\n// console.log(addRust(2, 3), iterRust(0, 0, 255));\nconst canvas = document.getElementById(\"canvas\");\nconst canvas2 = document.getElementById(\"canvas2\");\nconst ctx = canvas.getContext(\"2d\");\nconst imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n\nconst WIDTH = canvas.clientWidth;\nconst HEIGHT = canvas.clientHeight;\nconsole.log(WIDTH, HEIGHT);\n\n// let bounds = [{r: -2, i: -1}, {r: 1, i: 1}];\n// let bounds = [\n//   { r: -1.0239051845552098, i: -0.36249787751053836 },\n//   { r: -1.0239051835666346, i: -0.362497876851488 }\n// ];\nlet bounds = [{\"r\":0.2361513689220573,\"i\":-0.5210970613723728},{\"r\":0.23662026741217732,\"i\":-0.5207844623789595}]\n\nconst makeXY = bounds => {\n  const gWIDTH = bounds[1].r - bounds[0].r;\n  const gHEIGHT = bounds[1].i - bounds[0].i;\n  const gLEFT = bounds[0].r;\n  const gTOP = bounds[1].i;\n  const scaleX = gWIDTH / (WIDTH - 1);\n  const scaleY = -gHEIGHT / (HEIGHT - 1);\n  return (r, c) => ({ r: c * scaleX + gLEFT, i: r * scaleY + gTOP });\n};\n\nconst add = (c1, c2) => ({ r: c1.r + c2.r, i: c1.i + c2.i });\n\nconst mult = (c, scaler) => ({ r: c.r * scaler, i: c.i * scaler });\n\n// Note: iter and iterRust seem to be about the same speed. Probably any speed gains are offset by the back-and-forth between JS and Rust.\nconst iter = (r, i) => {\n  let pzr = 0;\n  let pzrs = 0;\n  let pzis = 0;\n  let zr = 0;\n  let zi = 0;\n  let n = 0;\n  for (n = 0; n < 1024; n++) {\n    if (pzrs + pzis > 4) {\n      break;\n    }\n    zr = pzrs - pzis + r;\n    zi = pzr * zi;\n    zi += zi;\n    zi += i;\n\n    pzr = zr;\n    pzrs = pzr * pzr;\n    pzis = zi * zi;\n  }\n  if (n === 1024) return n;\n  const smoothingMagic = 1.0 - Math.log( (Math.log2(pzrs + pzis) / 2.0) / Math.log(2.0) ) / Math.log(2.0);\n  return n + smoothingMagic;\n};\n\n// HSVtoRGB source: https://stackoverflow.com/a/17243070\nfunction HSVtoRGB(h, s, v) {\n  var r, g, b, i, f, p, q, t;\n  if (arguments.length === 1) {\n      s = h.s, v = h.v, h = h.h;\n  }\n  i = Math.floor(h * 6);\n  f = h * 6 - i;\n  p = v * (1 - s);\n  q = v * (1 - f * s);\n  t = v * (1 - (1 - f) * s);\n  switch (i % 6) {\n      case 0: r = v, g = t, b = p; break;\n      case 1: r = q, g = v, b = p; break;\n      case 2: r = p, g = v, b = t; break;\n      case 3: r = p, g = q, b = v; break;\n      case 4: r = t, g = p, b = v; break;\n      case 5: r = v, g = p, b = q; break;\n  }\n  return {\n      r: Math.round(r * 255),\n      g: Math.round(g * 255),\n      b: Math.round(b * 255)\n  };\n}\n\nconst drawCanvas = (\n  canvasWidth,\n  canvasHeight,\n  lowerBoundr,\n  lowerBoundi,\n  upperBoundr,\n  upperBoundi,\n  data\n) => {\n  let n = 0;\n  let min = 255;\n\n  const gWIDTH = upperBoundr - lowerBoundr;\n  const gLEFT = lowerBoundr;\n  const scaleX = gWIDTH / (canvasWidth - 1);\n\n  const gHEIGHT = upperBoundi - lowerBoundi;\n  const gTOP = upperBoundi;\n  const scaleY = -gHEIGHT / (canvasHeight - 1);\n  document.getElementById('scale').value = (2 / gHEIGHT).toExponential(2);\n\n  // let val;\n  let color;\n  for (let y = 0; y < canvasHeight; y++) {\n    for (let x = 0; x < canvasWidth; x++) {\n      let count = Math.max(0, iter(x * scaleX + gLEFT, y * scaleY + gTOP));\n      color = count === 1024 ? {r: 0, g: 0, b: 0} : HSVtoRGB(\n        count / 100.0,\n        0.9,\n        1.0\n      );\n      // min = Math.min(min, val);\n      data[n] = color.r;\n      data[n + 1] = color.g;\n      data[n + 2] = color.b;\n      data[n + 3] = 255;\n      n += 4;\n      if (hasExperimentalIsInputPending) {\n        if (navigator.scheduling.isInputPending(['wheel'])) {\n          console.log('wheel break!')\n          return false;\n        }\n        if (\n          isMouseDown\n          && navigator.scheduling.isInputPending(['mousemove'])\n          && !navigator.scheduling.isInputPending(['mouseup'])\n        ) {\n          return false;\n        }\n      }\n    }\n  }\n  return true;\n};\n\nconst draw = () => {\n  let start = performance.now();\n\n  let finished = drawCanvas(\n    WIDTH,\n    HEIGHT,\n    bounds[0].r,\n    bounds[0].i,\n    bounds[1].r,\n    bounds[1].i,\n    imageData.data\n  );\n  if (!finished) return;\n\n  console.log(\"draw\");\n  ctx.putImageData(imageData, 0, 0);\n  let finish = performance.now();\n  document.getElementById(\"ms\").value = Math.floor(finish - start);\n  console.log(JSON.stringify(bounds));\n};\n\ndraw();\ndraw();\ndraw();\n\nconst draw2 = () => {\n  let start = performance.now();\n\n  drawGL(\n    WIDTH,\n    HEIGHT,\n    bounds[0].r,\n    bounds[0].i,\n    bounds[1].r,\n    bounds[1].i\n  );\n\n  console.log(\"draw2\");\n  let finish = performance.now();\n  document.getElementById(\"ms2\").value = Math.floor(finish - start);\n  console.log(JSON.stringify(bounds));\n  // compute scale - redundant but needed so we can print the value\n  const gHEIGHT = bounds[1].i - bounds[0].i;\n  document.getElementById('scale2').value = (2 / gHEIGHT).toExponential(2);\n};\n\ndraw2();\n\ncanvas.addEventListener(\"wheel\", event => {\n  const xy = makeXY(bounds);\n  const c = xy(event.offsetY, event.offsetX);\n  const negc = mult(c, -1);\n  event.preventDefault();\n  // Compute new bounds\n  // 1. offset\n  bounds[0] = add(bounds[0], negc);\n  bounds[1] = add(bounds[1], negc);\n  // 2. scale\n  const scale = Math.max(1 + event.deltaY * 0.01, 0.7);\n  bounds[0] = mult(bounds[0], scale);\n  bounds[1] = mult(bounds[1], scale);\n  // 3. onset\n  bounds[0] = add(bounds[0], c);\n  bounds[1] = add(bounds[1], c);\n  draw();\n  draw2();\n});\n\n\ncanvas2.addEventListener(\"wheel\", event => {\n  const xy = makeXY(bounds);\n  const c = xy(event.offsetY, event.offsetX);\n  const negc = mult(c, -1);\n  event.preventDefault();\n  // Compute new bounds\n  // 1. offset\n  bounds[0] = add(bounds[0], negc);\n  bounds[1] = add(bounds[1], negc);\n  // 2. scale\n  const scale = Math.max(1 + event.deltaY * 0.01, 0.7);\n  bounds[0] = mult(bounds[0], scale);\n  bounds[1] = mult(bounds[1], scale);\n  // 3. onset\n  bounds[0] = add(bounds[0], c);\n  bounds[1] = add(bounds[1], c);\n  draw2();\n});\n\nlet prevMouseXY = null;\nlet isMouseDown = false;\n\nconst canvasOnMouseMove = event => {\n  const xy = makeXY(bounds);\n  const c = xy(event.offsetY, event.offsetX);\n  document.getElementById(\"output\").value = iter(c.r, c.i).toFixed(2);\n  if (isMouseDown) {\n    if (prevMouseXY) {\n      let prevC = xy(...prevMouseXY);\n      let diff = add(mult(c, -1), prevC);\n      bounds[0] = add(bounds[0], diff);\n      bounds[1] = add(bounds[1], diff);\n    }\n    prevMouseXY = [event.offsetY, event.offsetX];\n    draw();\n    draw2();\n  }\n  event.preventDefault();\n}\n\nif (hasExperimentalIsInputPending) {\n  canvas.addEventListener(\"mousemove\", canvasOnMouseMove);\n} else {\n  canvas.addEventListener(\n    \"mousemove\",\n    debounce(canvasOnMouseMove),\n    16\n  );\n}\n\ncanvas.addEventListener(\"mousedown\", event => {\n  isMouseDown = true;\n});\n\ncanvas2.addEventListener(\n  \"mousemove\",\n  debounce(event => {\n    const xy = makeXY(bounds);\n    const c = xy(event.offsetY, event.offsetX);\n    document.getElementById(\"output2\").value = iter(c.r, c.i).toFixed(2);\n\n    if (isMouseDown) {\n      if (prevMouseXY) {\n        let prevC = xy(...prevMouseXY);\n        let diff = add(mult(c, -1), prevC);\n        bounds[0] = add(bounds[0], diff);\n        bounds[1] = add(bounds[1], diff);\n      }\n      prevMouseXY = [event.offsetY, event.offsetX];\n      draw2();\n    }\n    event.preventDefault();\n  }),\n  16\n);\n\ncanvas2.addEventListener(\"mousedown\", event => {\n  isMouseDown = true;\n});\n\ndocument.addEventListener(\"mouseup\", event => {\n  isMouseDown = false;\n  prevMouseXY = null;\n});\n\n// https://github.com/hayes/just-debounce/blob/master/index.js\nfunction debounce(fn, delay, at_start, guarantee) {\n  var timeout;\n  var args;\n  var self;\n\n  return function debounced() {\n    self = this;\n    args = Array.prototype.slice.call(arguments);\n\n    if (timeout && (at_start || guarantee)) {\n      return;\n    } else if (!at_start) {\n      clear();\n\n      timeout = setTimeout(run, delay);\n      return timeout;\n    }\n\n    timeout = setTimeout(clear, delay);\n    fn.apply(self, args);\n\n    function run() {\n      clear();\n      fn.apply(self, args);\n    }\n\n    function clear() {\n      clearTimeout(timeout);\n      timeout = null;\n    }\n  };\n}\n"]}