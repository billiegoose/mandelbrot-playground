{"version":3,"sources":["src/utils/HSVtoRGB.js","src/utils/iter.js","src/worker.js"],"names":["HSVtoRGB","h","s","v","r","g","b","i","f","p","q","t","arguments","length","Math","floor","round","iter","pzr","pzrs","pzis","zi","n","log","log2","ctx","WIDTH","HEIGHT","imageData","bounds","onmessage","evt","console","data","canvas","getContext","getImageData","width","height","draw","performance","now","drawCanvas","putImageData","self","postMessage","done","canvasWidth","canvasHeight","lowerBoundr","lowerBoundi","upperBoundr","upperBoundi","color","gLEFT","scaleX","gTOP","scaleY","y","x","count","max"],"mappings":"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","file":"worker.69c87948.js","sourceRoot":"..","sourcesContent":["// HSVtoRGB source: https://stackoverflow.com/a/17243070\nexport function HSVtoRGB(h, s, v) {\n  var r, g, b, i, f, p, q, t;\n  if (arguments.length === 1) {\n      s = h.s, v = h.v, h = h.h;\n  }\n  i = Math.floor(h * 6);\n  f = h * 6 - i;\n  p = v * (1 - s);\n  q = v * (1 - f * s);\n  t = v * (1 - (1 - f) * s);\n  switch (i % 6) {\n      case 0: r = v, g = t, b = p; break;\n      case 1: r = q, g = v, b = p; break;\n      case 2: r = p, g = v, b = t; break;\n      case 3: r = p, g = q, b = v; break;\n      case 4: r = t, g = p, b = v; break;\n      case 5: r = v, g = p, b = q; break;\n  }\n  return {\n      r: Math.round(r * 255),\n      g: Math.round(g * 255),\n      b: Math.round(b * 255)\n  };\n}\n","// Note: iter and iterRust seem to be about the same speed. Probably any speed gains are offset by the back-and-forth between JS and Rust.\nexport const iter = (r, i) => {\n  let pzr = 0;\n  let pzrs = 0;\n  let pzis = 0;\n  let zr = 0;\n  let zi = 0;\n  let n = 0;\n  for (n = 0; n < 1024; n++) {\n    if (pzrs + pzis > 4) {\n      break;\n    }\n    zr = pzrs - pzis + r;\n    zi = pzr * zi;\n    zi += zi;\n    zi += i;\n\n    pzr = zr;\n    pzrs = pzr * pzr;\n    pzis = zi * zi;\n  }\n  if (n === 1024) return n;\n  const smoothingMagic = 1.0 - Math.log( (Math.log2(pzrs + pzis) / 2.0) / Math.log(2.0) ) / Math.log(2.0);\n  return n + smoothingMagic;\n};\n","import { HSVtoRGB } from './utils/HSVtoRGB.js'\nimport { iter } from './utils/iter.js'\n\nvar ctx\nvar WIDTH\nvar HEIGHT\nvar imageData\nlet bounds = [{\"r\":0.2361513689220573,\"i\":-0.5210970613723728},{\"r\":0.23662026741217732,\"i\":-0.5207844623789595}]\n\n\nonmessage = function(evt) {\n  console.log(evt.data)\n  if (evt.data.WIDTH) {\n    WIDTH = evt.data.WIDTH\n  }\n  if (evt.data.HEIGHT) {\n    HEIGHT = evt.data.HEIGHT\n  }\n  if (evt.data.canvas) {\n    var canvas = evt.data.canvas;\n    ctx = canvas.getContext(\"2d\");\n    imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n    draw();\n  }\n  if (evt.data.bounds) {\n    bounds = evt.data.bounds\n    draw();\n  }\n};\n\n\nconst draw = () => {\n  let start = performance.now();\n\n  let finished = drawCanvas(\n    WIDTH,\n    HEIGHT,\n    bounds[0].r,\n    bounds[0].i,\n    bounds[1].r,\n    bounds[1].i,\n    imageData.data\n  );\n  if (!finished) return;\n\n  console.log(\"draw3\");\n  ctx.putImageData(imageData, 0, 0);\n  let finish = performance.now();\n  self.postMessage({done: true})\n  // document.getElementById(\"ms\").value = Math.floor(finish - start);\n  // console.log(JSON.stringify(bounds));\n};\n\nconst drawCanvas = (\n  canvasWidth,\n  canvasHeight,\n  lowerBoundr,\n  lowerBoundi,\n  upperBoundr,\n  upperBoundi,\n  data\n) => {\n  let n = 0;\n\n  const gWIDTH = upperBoundr - lowerBoundr;\n  const gLEFT = lowerBoundr;\n  const scaleX = gWIDTH / (canvasWidth - 1);\n\n  const gHEIGHT = upperBoundi - lowerBoundi;\n  const gTOP = upperBoundi;\n  const scaleY = -gHEIGHT / (canvasHeight - 1);\n\n  // let val;\n  let color;\n  for (let y = 0; y < canvasHeight; y++) {\n    for (let x = 0; x < canvasWidth; x++) {\n      let count = Math.max(0, iter(x * scaleX + gLEFT, y * scaleY + gTOP));\n      color = count === 1024 ? {r: 0, g: 0, b: 0} : HSVtoRGB(\n        count / 100.0,\n        0.9,\n        1.0\n      );\n      data[n] = color.r;\n      data[n + 1] = color.g;\n      data[n + 2] = color.b;\n      data[n + 3] = 255;\n      n += 4;\n    }\n  }\n  return true;\n};\n\n"]}