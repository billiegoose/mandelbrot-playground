{"version":3,"sources":["src/shader.js","src/index.js"],"names":["vertexShaderSource","fragmentShaderSource","gl","getContext","document","getElementById","viewport","drawingBufferWidth","drawingBufferHeight","clearColor","clear","COLOR_BUFFER_BIT","vertexShader","compileShader","VERTEX_SHADER","fragmentShader","FRAGMENT_SHADER","program","buildProgram","resolutionLocation","getUniformLocation","uniform2f","console","log","scaleX","uniform1f","gLEFT","scaleY","gTOP","enableVertexAttribArray","buffer","createBuffer","cleanup","useProgram","deleteBuffer","deleteProgram","canvas","width","clientWidth","height","clientHeight","source","type","shader","createShader","shaderSource","createProgram","attachShader","linkProgram","detachShader","deleteShader","getProgramParameter","LINK_STATUS","linkErrLog","getProgramInfoLog","Error","drawGL","canvasWidth","canvasHeight","lowerBoundr","lowerBoundi","upperBoundr","upperBoundi","gWIDTH","a_scaleX","a_gLEFT","a_scaleY","a_gTOP","bindBuffer","ARRAY_BUFFER","vertexAttribPointer","FLOAT","drawArrays","POINTS","canvas2","ctx","imageData","getImageData","WIDTH","HEIGHT","bounds","makeXY","r","gHEIGHT","i","c","add","c1","c2","mult","scaler","iter","pzr","pzrs","pzis","zi","n","Math","log2","HSVtoRGB","h","s","v","g","b","f","p","q","t","arguments","length","floor","round","drawCanvas","data","color","value","toExponential","hasExperimentalIsInputPending","navigator","scheduling","isInputPending","y","x","count","max","draw","start","performance","now","putImageData","finish","JSON","stringify","draw2","addEventListener","event","xy","offsetY","offsetX","negc","preventDefault","scale","deltaY","prevMouseXY","isMouseDown","debounce","fn","delay","at_start","guarantee","timeout","args","self","Array","prototype","slice","call","setTimeout","run","apply","clearTimeout","toFixed","prevC","diff"],"mappings":"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","file":"src.d9eeb8b2.js","sourceRoot":"..","sourcesContent":["// TODO: Learn how I can make the shader interactive.\n\nconst vertexShaderSource = `\n#version 100\nvoid main() {\ngl_Position = vec4(0.0, 0.0, 0.0, 1.0);\ngl_PointSize = 600.0;\n}`\n\nconst fragmentShaderSource = `\n#ifdef GL_ES\nprecision highp float;\n#endif\n\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\nuniform float scaleX;\nuniform float scaleY;\nuniform float gLEFT;\nuniform float gTOP;\n\n// hsv2rgb source: https://stackoverflow.com/a/17897228\n// All components are in the range [0…1], including hue.\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 mandelbrot(vec2 pos){\n  float zx = pos.x * scaleX + gLEFT;\n  float zy = pos.y * scaleY + gTOP;\n  \n  const int maxIter = 1024;\n  \n  float cx = zx * 1.0;\n  float cy = zy * 1.0;\n  \n  float count = 0.0;\n  \n  for(int i = 0; i < maxIter; ++i){\n    if (zx * zx + zy * zy > 4.0) break;\n    \n    float temp = zx * zx - zy * zy;\n    \n    zy = 2.0 * zx * zy + cy;\n    zx = temp + cx;\n    \n    count += 1.0;\n  }\n  if (count == float(maxIter)) return vec3(0.0, 0.0, 0.0);\n  float smoothingMagic = 1.0 - log( (log2(zy * zy + zx * zx) / 2.0) / log(2.0) ) / log(2.0);\n  return hsv2rgb(vec3((count + smoothingMagic) / 100.0, 0.9, 1.0));\n}\n\nvoid main( void ) {\n  vec2 position = gl_FragCoord.xy / resolution;\n  vec3 color = mandelbrot(position);\n  gl_FragColor = vec4(color, 1.0 );\n}`\n\nlet gl = getContext(document.getElementById(\"canvas2\"));\n\ngl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);\ngl.clearColor(0.0, 0.0, 0.0, 1.0);\ngl.clear(gl.COLOR_BUFFER_BIT);\n\nlet vertexShader = compileShader(gl, vertexShaderSource, gl.VERTEX_SHADER);\nlet fragmentShader = compileShader(gl, fragmentShaderSource, gl.FRAGMENT_SHADER);\nlet program = buildProgram(gl, vertexShader, fragmentShader);\n\nvar resolutionLocation = gl.getUniformLocation(program, \"resolution\");\ngl.uniform2f(resolutionLocation, 600.0, 400.0);\nconsole.log(resolutionLocation);\n\nvar scaleX = gl.getUniformLocation(program, \"scaleX\");\ngl.uniform1f(scaleX, 3);\nvar gLEFT = gl.getUniformLocation(program, \"gLEFT\");\ngl.uniform1f(gLEFT, -2);\n\nvar scaleY = gl.getUniformLocation(program, \"scaleY\");\ngl.uniform1f(scaleY, 2.0);\nvar gTOP = gl.getUniformLocation(program, \"gTOP\");\ngl.uniform1f(gTOP, -1);\n\ngl.enableVertexAttribArray(0);\nconst buffer = gl.createBuffer();\ngl.bindBuffer(gl.ARRAY_BUFFER, buffer);\ngl.vertexAttribPointer(0, 1, gl.FLOAT, false, 0, 0);\n\ngl.drawArrays(gl.POINTS, 0, 1);\n\nfunction cleanup(gl, buffer, program) {\n  gl.useProgram(null);\n  if (buffer) gl.deleteBuffer(buffer);\n  if (program) gl.deleteProgram(program);\n}\n\nfunction getContext (canvas) {\n  canvas.width = canvas.clientWidth;\n  canvas.height = canvas.clientHeight;\n  return canvas.getContext(\"webgl\");\n}\n\nfunction compileShader (gl, source, type) {\n  const shader = gl.createShader(type);\n  gl.shaderSource(shader, source);\n  gl.compileShader(shader);\n  return shader;\n}\n\nfunction buildProgram (gl, vertexShader, fragmentShader) {\n  const program = gl.createProgram();\n  gl.attachShader(program, vertexShader);\n  gl.attachShader(program, fragmentShader);\n  gl.linkProgram(program);\n  gl.detachShader(program, vertexShader);\n  gl.detachShader(program, fragmentShader);\n  gl.deleteShader(vertexShader);\n  gl.deleteShader(fragmentShader);\n\n  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n    const linkErrLog = gl.getProgramInfoLog(program);\n    gl.useProgram(null);\n    gl.deleteProgram(program);\n    throw new Error(\"Shader program did not link successfully. \" + \"Error log: \" + linkErrLog);\n  }\n  gl.useProgram(program);\n  return program;\n}\n\nexport function drawGL(\n  canvasWidth,\n  canvasHeight,\n  lowerBoundr,\n  lowerBoundi,\n  upperBoundr,\n  upperBoundi\n) {\n  const gWIDTH = upperBoundr - lowerBoundr;\n  const gLEFT = lowerBoundr;\n  const scaleX = gWIDTH;\n\n  const gHEIGHT = upperBoundi - lowerBoundi;\n  const gTOP = lowerBoundi;\n  const scaleY = gHEIGHT;\n\n  var resolutionLocation = gl.getUniformLocation(program, \"resolution\");\n  gl.uniform2f(resolutionLocation, canvasWidth, canvasHeight);\n\n  var a_scaleX = gl.getUniformLocation(program, \"scaleX\");\n  gl.uniform1f(a_scaleX, scaleX);\n  var a_gLEFT = gl.getUniformLocation(program, \"gLEFT\");\n  gl.uniform1f(a_gLEFT, gLEFT);\n\n  var a_scaleY = gl.getUniformLocation(program, \"scaleY\");\n  gl.uniform1f(a_scaleY, scaleY);\n  var a_gTOP = gl.getUniformLocation(program, \"gTOP\");\n  gl.uniform1f(a_gTOP, gTOP);\n\n  gl.enableVertexAttribArray(0);\n  const buffer = gl.createBuffer();\n  gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n  gl.vertexAttribPointer(0, 1, gl.FLOAT, false, 0, 0);\n\n  gl.drawArrays(gl.POINTS, 0, 1);\n}\n","\"use strict\";\nimport { drawGL } from \"./shader.js\"\n// import { add as addRust, iter as iterRust } from \"./draw.rs\";\n\n// console.log(addRust(2, 3), iterRust(0, 0, 255));\nconst canvas = document.getElementById(\"canvas\");\nconst canvas2 = document.getElementById(\"canvas2\");\nconst ctx = canvas.getContext(\"2d\");\nconst imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n\nconst WIDTH = canvas.clientWidth;\nconst HEIGHT = canvas.clientHeight;\nconsole.log(WIDTH, HEIGHT);\n\n// let bounds = [{r: -2, i: -1}, {r: 1, i: 1}];\n// let bounds = [\n//   { r: -1.0239051845552098, i: -0.36249787751053836 },\n//   { r: -1.0239051835666346, i: -0.362497876851488 }\n// ];\nlet bounds = [{\"r\":0.2361513689220573,\"i\":-0.5210970613723728},{\"r\":0.23662026741217732,\"i\":-0.5207844623789595}]\n\nconst makeXY = bounds => {\n  const gWIDTH = bounds[1].r - bounds[0].r;\n  const gHEIGHT = bounds[1].i - bounds[0].i;\n  const gLEFT = bounds[0].r;\n  const gTOP = bounds[1].i;\n  const scaleX = gWIDTH / (WIDTH - 1);\n  const scaleY = -gHEIGHT / (HEIGHT - 1);\n  return (r, c) => ({ r: c * scaleX + gLEFT, i: r * scaleY + gTOP });\n};\n\nconst add = (c1, c2) => ({ r: c1.r + c2.r, i: c1.i + c2.i });\n\nconst mult = (c, scaler) => ({ r: c.r * scaler, i: c.i * scaler });\n\n// Note: iter and iterRust seem to be about the same speed. Probably any speed gains are offset by the back-and-forth between JS and Rust.\nconst iter = (r, i) => {\n  let pzr = 0;\n  let pzrs = 0;\n  let pzis = 0;\n  let zr = 0;\n  let zi = 0;\n  let n = 0;\n  for (n = 0; n < 1024; n++) {\n    if (pzrs + pzis > 4) {\n      break;\n    }\n    zr = pzrs - pzis + r;\n    zi = pzr * zi;\n    zi += zi;\n    zi += i;\n\n    pzr = zr;\n    pzrs = pzr * pzr;\n    pzis = zi * zi;\n  }\n  if (n === 1024) return n;\n  const smoothingMagic = 1.0 - Math.log( (Math.log2(pzrs + pzis) / 2.0) / Math.log(2.0) ) / Math.log(2.0);\n  return n + smoothingMagic;\n};\n\n// HSVtoRGB source: https://stackoverflow.com/a/17243070\nfunction HSVtoRGB(h, s, v) {\n  var r, g, b, i, f, p, q, t;\n  if (arguments.length === 1) {\n      s = h.s, v = h.v, h = h.h;\n  }\n  i = Math.floor(h * 6);\n  f = h * 6 - i;\n  p = v * (1 - s);\n  q = v * (1 - f * s);\n  t = v * (1 - (1 - f) * s);\n  switch (i % 6) {\n      case 0: r = v, g = t, b = p; break;\n      case 1: r = q, g = v, b = p; break;\n      case 2: r = p, g = v, b = t; break;\n      case 3: r = p, g = q, b = v; break;\n      case 4: r = t, g = p, b = v; break;\n      case 5: r = v, g = p, b = q; break;\n  }\n  return {\n      r: Math.round(r * 255),\n      g: Math.round(g * 255),\n      b: Math.round(b * 255)\n  };\n}\n\nconst drawCanvas = (\n  canvasWidth,\n  canvasHeight,\n  lowerBoundr,\n  lowerBoundi,\n  upperBoundr,\n  upperBoundi,\n  data\n) => {\n  let n = 0;\n  let min = 255;\n\n  const gWIDTH = upperBoundr - lowerBoundr;\n  const gLEFT = lowerBoundr;\n  const scaleX = gWIDTH / (canvasWidth - 1);\n\n  const gHEIGHT = upperBoundi - lowerBoundi;\n  const gTOP = upperBoundi;\n  const scaleY = -gHEIGHT / (canvasHeight - 1);\n  document.getElementById('scale').value = (2 / gHEIGHT).toExponential(2);\n\n  // let val;\n  let color;\n  const hasExperimentalIsInputPending = navigator.scheduling && navigator.scheduling.isInputPending;\n\n  for (let y = 0; y < canvasHeight; y++) {\n    for (let x = 0; x < canvasWidth; x++) {\n      let count = Math.max(0, iter(x * scaleX + gLEFT, y * scaleY + gTOP));\n      color = count === 1024 ? {r: 0, g: 0, b: 0} : HSVtoRGB(\n        count / 100.0,\n        0.9,\n        1.0\n      );\n      // min = Math.min(min, val);\n      data[n] = color.r;\n      data[n + 1] = color.g;\n      data[n + 2] = color.b;\n      data[n + 3] = 255;\n      n += 4;\n      if (hasExperimentalIsInputPending) {\n        if (navigator.scheduling.isInputPending(['wheel'])) break;\n      }\n    }\n  }\n  return;\n};\n\nconst draw = () => {\n  let start = performance.now();\n\n  drawCanvas(\n    WIDTH,\n    HEIGHT,\n    bounds[0].r,\n    bounds[0].i,\n    bounds[1].r,\n    bounds[1].i,\n    imageData.data\n  );\n\n  console.log(\"draw\");\n  ctx.putImageData(imageData, 0, 0);\n  let finish = performance.now();\n  document.getElementById(\"ms\").value = Math.floor(finish - start);\n  console.log(JSON.stringify(bounds));\n};\n\ndraw();\ndraw();\ndraw();\n\nconst draw2 = () => {\n  let start = performance.now();\n\n  drawGL(\n    WIDTH,\n    HEIGHT,\n    bounds[0].r,\n    bounds[0].i,\n    bounds[1].r,\n    bounds[1].i\n  );\n\n  console.log(\"draw2\");\n  let finish = performance.now();\n  document.getElementById(\"ms2\").value = Math.floor(finish - start);\n  console.log(JSON.stringify(bounds));\n  // compute scale - redundant but needed so we can print the value\n  const gHEIGHT = bounds[1].i - bounds[0].i;\n  document.getElementById('scale2').value = (2 / gHEIGHT).toExponential(2);\n};\n\ndraw2();\n\ncanvas.addEventListener(\"wheel\", event => {\n  const xy = makeXY(bounds);\n  const c = xy(event.offsetY, event.offsetX);\n  const negc = mult(c, -1);\n  event.preventDefault();\n  // Compute new bounds\n  // 1. offset\n  bounds[0] = add(bounds[0], negc);\n  bounds[1] = add(bounds[1], negc);\n  // 2. scale\n  const scale = Math.max(1 + event.deltaY * 0.01, 0.7);\n  bounds[0] = mult(bounds[0], scale);\n  bounds[1] = mult(bounds[1], scale);\n  // 3. onset\n  bounds[0] = add(bounds[0], c);\n  bounds[1] = add(bounds[1], c);\n  draw();\n  draw2();\n});\n\n\ncanvas2.addEventListener(\"wheel\", event => {\n  const xy = makeXY(bounds);\n  const c = xy(event.offsetY, event.offsetX);\n  const negc = mult(c, -1);\n  event.preventDefault();\n  // Compute new bounds\n  // 1. offset\n  bounds[0] = add(bounds[0], negc);\n  bounds[1] = add(bounds[1], negc);\n  // 2. scale\n  const scale = Math.max(1 + event.deltaY * 0.01, 0.7);\n  bounds[0] = mult(bounds[0], scale);\n  bounds[1] = mult(bounds[1], scale);\n  // 3. onset\n  bounds[0] = add(bounds[0], c);\n  bounds[1] = add(bounds[1], c);\n  draw2();\n});\n\nlet prevMouseXY = null;\nlet isMouseDown = false;\n\ncanvas.addEventListener(\n  \"mousemove\",\n  debounce(event => {\n    const xy = makeXY(bounds);\n    const c = xy(event.offsetY, event.offsetX);\n    document.getElementById(\"output\").value = iter(c.r, c.i).toFixed(2);\n    if (isMouseDown) {\n      if (prevMouseXY) {\n        let prevC = xy(...prevMouseXY);\n        let diff = add(mult(c, -1), prevC);\n        bounds[0] = add(bounds[0], diff);\n        bounds[1] = add(bounds[1], diff);\n      }\n      prevMouseXY = [event.offsetY, event.offsetX];\n      draw();\n      draw2();\n    }\n    event.preventDefault();\n  }),\n  16\n);\n\ncanvas.addEventListener(\"mousedown\", event => {\n  isMouseDown = true;\n});\n\n\ncanvas2.addEventListener(\n  \"mousemove\",\n  debounce(event => {\n    const xy = makeXY(bounds);\n    const c = xy(event.offsetY, event.offsetX);\n    document.getElementById(\"output2\").value = iter(c.r, c.i).toFixed(2);\n\n    if (isMouseDown) {\n      if (prevMouseXY) {\n        let prevC = xy(...prevMouseXY);\n        let diff = add(mult(c, -1), prevC);\n        bounds[0] = add(bounds[0], diff);\n        bounds[1] = add(bounds[1], diff);\n      }\n      prevMouseXY = [event.offsetY, event.offsetX];\n      draw2();\n    }\n    event.preventDefault();\n  }),\n  16\n);\n\ncanvas2.addEventListener(\"mousedown\", event => {\n  isMouseDown = true;\n});\n\ndocument.addEventListener(\"mouseup\", event => {\n  isMouseDown = false;\n  prevMouseXY = null;\n});\n\n// https://github.com/hayes/just-debounce/blob/master/index.js\nfunction debounce(fn, delay, at_start, guarantee) {\n  var timeout;\n  var args;\n  var self;\n\n  return function debounced() {\n    self = this;\n    args = Array.prototype.slice.call(arguments);\n\n    if (timeout && (at_start || guarantee)) {\n      return;\n    } else if (!at_start) {\n      clear();\n\n      timeout = setTimeout(run, delay);\n      return timeout;\n    }\n\n    timeout = setTimeout(clear, delay);\n    fn.apply(self, args);\n\n    function run() {\n      clear();\n      fn.apply(self, args);\n    }\n\n    function clear() {\n      clearTimeout(timeout);\n      timeout = null;\n    }\n  };\n}\n"]}